name: MLOps CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  # Set to 'true' for faster builds (skips full testing)
  FAST_BUILD: ${{ github.event_name == 'push' && github.ref != 'refs/heads/main' }}
  SKIP_TESTS: ${{ github.event_name == 'push' && github.ref != 'refs/heads/main' }}

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python3.10/site-packages
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}-v2
          restore-keys: |
            ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}-
            ${{ runner.os }}-pip-

      - name: Cache NLTK data
        uses: actions/cache@v3
        with:
          path: ~/nltk_data
          key: ${{ runner.os }}-nltk-data-v1

      - name: Install dependencies (optimized)
        run: |
          python -m pip install --upgrade pip setuptools wheel
          
          # Use faster requirements file for CI builds
          if [ "${{ env.FAST_BUILD }}" == "true" ]; then
            echo "ðŸš€ Fast build mode - using minimal requirements"
            pip install --no-cache-dir -r requirements-ci.txt
          else
            echo "ðŸ” Full build mode - installing all requirements"
            pip install --no-cache-dir -r requirements.txt
          fi
          
          # Download NLTK data only if not cached
          python -c "
          import nltk
          import os
          
          nltk_data_dir = os.path.expanduser('~/nltk_data')
          if not os.path.exists(f'{nltk_data_dir}/tokenizers/punkt'):
              print('Downloading NLTK data...')
              nltk.download('punkt', quiet=True)
              nltk.download('stopwords', quiet=True) 
              nltk.download('wordnet', quiet=True)
              nltk.download('omw-1.4', quiet=True)
          else:
              print('NLTK data already cached')
          "

      - name: Run DVC pipeline
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          dvc repro

      - name: Run tests (optional - set SKIP_TESTS=true to skip)
        if: env.SKIP_TESTS != 'true'
        run: |
          if [ -d "tests" ]; then
            python -m pytest tests/ -v --tb=short --maxfail=3
          else
            echo "No tests directory found, skipping tests"
          fi

      - name: Validate model artifacts
        run: |
          ls -la models/
          python -c "
          import pickle
          try:
              model = pickle.load(open('models/model.pkl', 'rb'))
              print('âœ… Model loaded successfully')
              vectorizer = pickle.load(open('models/vectorizer.pkl', 'rb'))
              print('âœ… Vectorizer loaded successfully')
          except Exception as e:
              print(f'âŒ Model validation failed: {e}')
              exit(1)
          "

      - name: Promote model to production
        if: success()
        env:
          CAPSTONE_TEST: ${{ secrets.CAPSTONE_TEST }}
        run: |
          if [ -f "scripts/promote_model.py" ]; then
            python scripts/promote_model.py
          else
            echo "No promote_model.py script found, skipping model promotion"
          fi

      - name: Configure AWS credentials
        if: success()
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        if: success()
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        if: success()
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image (with cache)
        if: success()
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image with cache optimization..."
          
          # Try to pull existing image for cache
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest || echo "No cached image found"
          
          # Build with cache from previous image
          docker build \
            --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .

      - name: Push Docker image to ECR
        if: success()
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Pushing Docker image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "Image pushed successfully!"
          echo "Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Pipeline completion summary
        if: success()
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ðŸŽ‰ CI/CD Pipeline completed successfully!"
          echo "ðŸ“¦ Docker image built and pushed to ECR:"
          echo "   Repository: $ECR_REGISTRY/$ECR_REPOSITORY"
          echo "   Tags: latest, $IMAGE_TAG"
          echo ""
          echo "ðŸš€ Next steps (manual):"
          echo "   1. Create EKS cluster: eksctl create cluster --name flask-app-cluster --region ${{ secrets.AWS_REGION }}"
          echo "   2. Deploy to EKS: kubectl create deployment sentiment-app --image=$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          echo "   3. Expose service: kubectl expose deployment sentiment-app --type=LoadBalancer --port=5000"
          echo ""
          echo "ðŸ’¡ To enable automatic EKS deployment, uncomment the EKS deployment step in ci.yaml"

      # ========================================
      # EKS DEPLOYMENT (COMMENTED OUT FOR NOW)
      # Uncomment this section when ready to deploy to EKS
      # ========================================
      
      # - name: Deploy to EKS (DISABLED - uncomment when ready)
      #   if: success() && github.ref == 'refs/heads/main'
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      #     IMAGE_TAG: ${{ github.sha }}
      #     EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
      #   run: |
      #     # Check if EKS cluster exists
      #     if aws eks describe-cluster --name $EKS_CLUSTER_NAME --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
      #       echo "EKS cluster $EKS_CLUSTER_NAME found, updating kubeconfig..."
      #       aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name $EKS_CLUSTER_NAME
      #       
      #       # Check if deployment exists, create if not
      #       if kubectl get deployment sentiment-app >/dev/null 2>&1; then
      #         echo "Updating existing deployment..."
      #         kubectl set image deployment/sentiment-app sentiment-app=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      #         kubectl rollout status deployment/sentiment-app
      #       else
      #         echo "Creating new deployment..."
      #         kubectl create deployment sentiment-app --image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      #         kubectl expose deployment sentiment-app --type=LoadBalancer --port=5000 --target-port=5000 --name=sentiment-app-service
      #         echo "Deployment created successfully!"
      #       fi
      #       
      #       kubectl get pods
      #       kubectl get services
      #     else
      #       echo "EKS cluster $EKS_CLUSTER_NAME not found, skipping EKS deployment"
      #       echo "To deploy to EKS, create cluster first: eksctl create cluster --name $EKS_CLUSTER_NAME --region ${{ secrets.AWS_REGION }}"
      #     fi